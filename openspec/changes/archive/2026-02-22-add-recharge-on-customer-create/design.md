## Context

当前干洗系统的客户管理和储值充值功能分离：
- **客户管理**：在 `CustomerListScreen` 中创建客户，通过 `CustomerEditDialog` 输入基本信息
- **储值充值**：在 `RechargeScreen` 中单独进行充值操作，需要 20% 赠送金额计算

现有代码结构：
- **后端**：`CustomerController` 处理客户 CRUD，`PrepaidController` 处理充值逻辑
- **Android**：使用 Jetpack Compose 构建 UI，MVVM 架构，`CustomerViewModel` 和 `RechargeViewModel` 分别管理状态
- **数据库**：`customer` 表包含 balance 字段，`recharge_record` 表记录充值历史

业务规则：
- 充值享受 20% 赠送（充值 100 元，实际到账 120 元）
- 充值金额需为 100 的整数倍

## Goals / Non-Goals

**Goals:**
- 在创建客户时提供"创建并充值"选项，减少用户操作步骤
- 保持现有充值业务逻辑（20% 赠送、100 元整数倍）不变
- 后端 API 向后兼容，不影响现有仅创建客户的功能
- Android 端提供流畅的用户体验，创建后自动跳转充值页面

**Non-Goals:**
- 不修改现有充值计算逻辑
- 不改变客户数据结构
- 不涉及批量创建客户场景
- 不修改现有独立充值页面的功能

## Decisions

### 1. API 设计：扩展 vs 新建接口

**决策**：扩展现有 `POST /api/customers` 接口，添加可选的 `rechargeAmount` 参数

**理由**：
- 保持 API 简洁，避免重复端点
- 向后兼容，现有调用方不受影响
- 原子操作：创建客户和充值记录在同一事务中完成

**备选方案**：
- 新建 `POST /api/customers/with-recharge` 端点 → 增加 API 复杂度，不采用

### 2. 充值逻辑位置

**决策**：充值计算逻辑（20% 赠送）放在后端，前端仅展示计算结果

**理由**：
- 保持业务逻辑单一来源，避免前后端计算不一致
- 符合现有 `PrepaidController` 的设计模式
- 前端只负责展示和输入验证

### 3. Android UI 交互流程

**决策**：在 `CustomerEditDialog` 中增加"充值金额"输入框和"创建并充值"按钮

**理由**：
- 用户在一个对话框内完成所有操作，无需跳转
- 符合 Material Design 对话框模式
- 与现有 `CustomerEditDialog` 风格一致

**备选方案**：
- 创建客户后自动跳转到 `RechargeScreen` → 增加页面跳转，体验割裂，不采用

### 4. 数据一致性

**决策**：使用 Spring `@Transactional` 确保创建客户和充值记录的原子性

**理由**：
- 避免部分成功导致的数据不一致
- MyBatis-Plus 和 Spring 事务管理已配置，实现简单

## Risks / Trade-offs

**[风险]** 前端输入验证不足导致无效充值请求 → **缓解**：前后端双重验证，后端返回明确错误信息

**[风险]** 用户误操作创建大额充值 → **缓解**：增加确认对话框，显示充值金额、赠送金额和实际到账金额

**[风险]** 网络超时导致重复充值 → **缓解**：前端禁用重复提交按钮，后端可考虑添加请求幂等性（本次暂不实现）

**[权衡]** 增加 API 参数复杂度 → 接受，通过可选参数保持向后兼容

**[权衡]** 对话框内充值输入可能使对话框过高 → 接受，通过合理的 UI 布局控制高度
